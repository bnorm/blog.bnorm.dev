<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Writing Your Second Kotlin Compiler Plugin, Part 3 ‚Äî Navigating Kotlin IR ¬∑ Dev Blog by Brian</title> <meta name="description" content=" At the time of writing this article, Kotlin compatibility for IR backend is in Alpha status andthe compiler plugin API is Experimental. As such, informatio..."> <link rel="icon" href="https://blog.bnorm.dev/assets/favicon.png"> <link rel="apple-touch-icon" href="https://blog.bnorm.dev/assets/touch-icon.png"> <link rel="stylesheet" href="https://blog.bnorm.dev/assets/core.css"> <link rel="canonical" href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-3"> <link rel="alternate" type="application/atom+xml" title="Dev Blog by Brian" href="https://blog.bnorm.dev/feed.xml" /> <!-- OpenGraph metadatas --> <meta name="og:type" content="article"> <meta name="og:site_name" content="Dev Blog by Brian"> <meta name="og:title" content="Writing Your Second Kotlin Compiler Plugin, Part 3 ‚Äî Navigating Kotlin IR"> <meta name="og:url" content="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-3"> <meta name="og:description" content="Navigating Kotlin IR"> <!-- Twitter cards metadatas --> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@bnormcodes"> <meta name="twitter:creator" content="@bnormcodes"> <meta name="twitter:title" content="Writing Your Second Kotlin Compiler Plugin, Part 3 ‚Äî Navigating Kotlin IR"> <meta name="twitter:url" content="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-3"> <meta name="twitter:description" content="Navigating Kotlin IR"> <!-- Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SH69BHV31K"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SH69BHV31K'); </script> </head> <body> <div class="header"> <aside class="logo"> <a href="https://blog.bnorm.dev/"> <img src="https://avatars2.githubusercontent.com/u/1074449?v=4" alt="" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <div class="social-media-list"> <div> <a href="https://github.com/bnorm"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> bnorm</a> </div> <div> <a href="https://www.twitter.com/bnormcodes"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> bnormcodes</a> </div> </div> </div> <div id="content"> <article> <div class="center"> <h1 class="title">Writing Your Second Kotlin Compiler Plugin, Part 3 ‚Äî Navigating Kotlin IR</h1> <time class="code">December 5, 2020</time> </div> <div class="divider"></div> <blockquote> <p>At the time of writing this article, <a href="https://kotlinlang.org/docs/reference/evolution/components-stability.html">Kotlin compatibility</a> for IR backend is in Alpha status and the compiler plugin API is Experimental. As such, information contained in this article about IR and compiler plugins could be out-of-date or incorrect. If official documentation exists, please refer to it first.</p> </blockquote> <p>Continuing on from <a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2">Part 2</a> where we learned how to inspect Kotlin IR, let‚Äôs explore how to navigate the Kotlin IR tree and inspect specific elements.</p> <ul> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-1">Part 1 - Project Setup</a></li> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2">Part 2 - Inspecting Kotlin IR</a></li> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-3">Part 3 - Navigating Kotlin IR</a></li> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-4">Part 4 - Building Kotlin IR</a></li> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-5">Part 5 - Transforming Kotlin IR</a></li> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-6">Part 6 - Support Libraries, Publishing, and Integration Testing</a></li> </ul> <h1 id="we-got-visitors">We Got Visitors!</h1> <p>As shown in <a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2">Part 2</a>, the Kotlin IR is an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> (AST). This means that fundamentally when dealing with Kotlin IR, we are dealing with a tree structure. We‚Äôll be dealing with things like parents, siblings, and children which all implement the same interface, <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a>. This interface shows us exactly how we will be navigating the Kotlin IR tree: with the <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a>! The <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a> interface has 2 functions which enable the visitor pattern.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="p">&lt;</span><span class="nc">R</span><span class="p">,</span> <span class="nc">D</span><span class="p">&gt;</span> <span class="nf">accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">R</span><span class="p">,</span> <span class="nc">D</span><span class="p">&gt;,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">D</span><span class="p">):</span> <span class="nc">R</span>
<span class="k">fun</span> <span class="p">&lt;</span><span class="nc">D</span><span class="p">&gt;</span> <span class="nf">acceptChildren</span><span class="p">(</span><span class="n">visitor</span><span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">Unit</span><span class="p">,</span> <span class="nc">D</span><span class="p">&gt;,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">D</span><span class="p">):</span> <span class="nc">Unit</span>
</code></pre></div></div> <p>Both of these functions take an <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/visitors/IrElementVisitor.kt#L23">IrElementVisitor</a>, which is another interface but with a lot more functions. An implementation of the <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/visitors/IrElementVisitor.kt#L23">IrElementVisitor</a> interface is what allows us to navigate a Kotlin IR tree, with the appropriate function being called when visiting that type of element.</p> <h1 id="top-to-bottom">Top To Bottom</h1> <p>If we inspect the default implementations of the functions of <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/visitors/IrElementVisitor.kt#L23">IrElementVisitor</a> we can learn a little about how the different nodes of the Kotlin IR tree are related. For example, lets take a look at the <code class="language-plaintext highlighter-rouge">visitClass</code> function.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">visitClass</span><span class="p">(</span><span class="n">declaration</span><span class="p">:</span> <span class="nc">IrClass</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">D</span><span class="p">)</span> <span class="p">=</span> <span class="nf">visitDeclaration</span><span class="p">(</span><span class="n">declaration</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div></div> <p>This function accepts an <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/declarations/IrClass.kt#L31">IrClass</a> and the default implementation delegates to another function, <code class="language-plaintext highlighter-rouge">visitDeclaration</code>. If you want to perform some operation on every <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/declarations/IrClass.kt#L31">IrClass</a>, you would provide a different implementation for this function. But let‚Äôs first continue down the call chain and look at the <code class="language-plaintext highlighter-rouge">visitDeclaration</code> function.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">visitDeclaration</span><span class="p">(</span><span class="n">declaration</span><span class="p">:</span> <span class="nc">IrDeclarationBase</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">D</span><span class="p">)</span> <span class="p">=</span> <span class="nf">visitElement</span><span class="p">(</span><span class="n">declaration</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div></div> <p>This function accepts an <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/declarations/IrDeclaration.kt#L48">IrDeclarationBase</a> and the default implementation delegates to yet another function, <code class="language-plaintext highlighter-rouge">visitElement</code>. Because we can call this function with an <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/declarations/IrClass.kt#L31">IrClass</a>, we know that IrClass must implement <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/declarations/IrDeclaration.kt#L48">IrDeclarationBase</a>. Finally, the <code class="language-plaintext highlighter-rouge">visitElement</code> function.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">visitElement</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">D</span><span class="p">):</span> <span class="nc">R</span>
</code></pre></div></div> <p>This <code class="language-plaintext highlighter-rouge">visitElement</code> function is the only function which does not have a default implementation. Since <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a> is the base interface for all IR elements, it makes sense that all functions in <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/visitors/IrElementVisitor.kt#L23">IrElementVisitor</a> eventually delegate to this <code class="language-plaintext highlighter-rouge">visitElement</code> function. This function is also what helps enable recursion to children of each element!</p> <h1 id="parents--siblings--children-oh-my">Parents &amp; Siblings &amp; Children, Oh My!</h1> <p>To further understand how the <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/visitors/IrElementVisitor.kt#L23">IrElementVisitor</a> works, we can take a look at how <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/declarations/IrClass.kt#L31">IrClass</a> implements the 2 functions from <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a> which accept a visitor implementation.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="nc">R</span><span class="p">,</span> <span class="nc">D</span><span class="p">&gt;</span> <span class="nf">accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">R</span><span class="p">,</span> <span class="nc">D</span><span class="p">&gt;,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">D</span><span class="p">):</span> <span class="nc">R</span> <span class="p">=</span>
    <span class="n">visitor</span><span class="p">.</span><span class="nf">visitClass</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">override</span> <span class="k">fun</span> <span class="p">&lt;</span><span class="nc">D</span><span class="p">&gt;</span> <span class="nf">acceptChildren</span><span class="p">(</span><span class="n">visitor</span><span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">Unit</span><span class="p">,</span> <span class="nc">D</span><span class="p">&gt;,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">D</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thisReceiver</span><span class="o">?.</span><span class="nf">accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">typeParameters</span><span class="p">.</span><span class="nf">forEach</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">declarations</span><span class="p">.</span><span class="nf">forEach</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="n">visitor</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>From this example, we can see that the <code class="language-plaintext highlighter-rouge">accept</code> function simply calls the appropriate visitor function. This polymorphic behavior allows a caller to properly handle any <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a> simply by calling <code class="language-plaintext highlighter-rouge">element.accept(visitor, data)</code>. This behavior of calling the appropriate visitor function is consistent across all element implementations.</p> <p>The <code class="language-plaintext highlighter-rouge">acceptChildren</code> calls the <code class="language-plaintext highlighter-rouge">accept</code> function on each child <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a> it contains. As we just learned, the <code class="language-plaintext highlighter-rouge">accept</code> function simply calls the appropriate visitor function. This means that by calling <code class="language-plaintext highlighter-rouge">element.acceptChildren(visitor, data)</code> the visitor will properly handle all children of the element. This leads us to how recursion works with the visitor pattern!</p> <p>Say we had the following visitor implementation.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">RecursiveVisitor</span> <span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">Unit</span><span class="p">,</span> <span class="nc">Nothing</span><span class="err">?</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">visitElement</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">Nothing</span><span class="p">?)</span> <span class="p">{</span>
    <span class="n">element</span><span class="p">.</span><span class="nf">acceptChildren</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>By calling <code class="language-plaintext highlighter-rouge">moduleFragment.accept(RecursiveVisitor(), null)</code> from an <a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-1#kotlin-plugin">IrGeneratorExtension</a> we would visit every single <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a> in the module! Don‚Äôt believe me? Add some print statements and try it for yourself. Can you recreate a simplified version of the <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/util/DumpIrTree.kt#L30">dump()</a> function we looked at in <a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2">Part 2</a>?</p> <h1 id="data-in-data-out">Data In, Data Out</h1> <p>Something we skipped over with <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/visitors/IrElementVisitor.kt#L23">IrElementVisitor</a> is the 2 type parameters it has, one defining the type of the <code class="language-plaintext highlighter-rouge">data</code> parameter each visit function accepts, and the other defining the return type for each visit function.</p> <p>The input value <code class="language-plaintext highlighter-rouge">data</code> can be used to pass contextual information throughout the IR navigation. For example, this could be the current indent spacing to use when printing out the details of an element.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">StringIndentVisitor</span> <span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">Unit</span><span class="p">,</span> <span class="nc">String</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">visitElement</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"$data${render(element)} {"</span><span class="p">)</span>
    <span class="n">element</span><span class="p">.</span><span class="nf">acceptChildren</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="s">"  $data"</span><span class="p">)</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"$data}"</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The output type can be used to return a result from accepting the visitor. There are rare occasions when this is useful (like IR transformation!) and usually the return type is just <code class="language-plaintext highlighter-rouge">Unit</code>. However, one example might be to find the root parent of an element.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Not as efficient as a while loop, but exemplifies how the output type could be used</span>
<span class="kd">class</span> <span class="nc">RootParentVisitor</span> <span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">IrDeclarationParent</span><span class="err">?</span><span class="p">,</span> <span class="nc">Nothing</span><span class="err">?</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">visitElement</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">Nothing</span><span class="p">?):</span> <span class="nc">IrDeclarationParent</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>

  <span class="k">override</span> <span class="k">fun</span> <span class="nf">visitDeclaration</span><span class="p">(</span><span class="n">declaration</span><span class="p">:</span> <span class="nc">IrDeclarationBase</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">Nothing</span><span class="p">?):</span> <span class="nc">IrDeclarationParent</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">parent</span> <span class="p">=</span> <span class="n">declaration</span><span class="p">.</span><span class="n">parent</span>
    <span class="k">return</span> <span class="n">parent</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="o">?:</span> <span class="n">parent</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Something interesting to notice, is that the <code class="language-plaintext highlighter-rouge">acceptChildren</code> only accepts a visitor of type <code class="language-plaintext highlighter-rouge">IrElementVisitor&lt;Unit, D&gt;</code>, which means that when performing recursive operations across all children, no data can be returned. If data needs to be returned from a recursive visitor, it is common pattern for the visitor to be passed some builder object which can be updated during traversal.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">CollectingVisitor</span><span class="p">(</span>
  <span class="k">private</span> <span class="kd">val</span> <span class="py">elements</span><span class="p">:</span> <span class="nc">MutableList</span><span class="p">&lt;</span><span class="nc">IrElement</span><span class="p">&gt;</span>
<span class="p">)</span> <span class="p">:</span> <span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">Unit</span><span class="p">,</span> <span class="nc">Nothing</span><span class="err">?</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">visitElement</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">Nothing</span><span class="p">?)</span> <span class="p">{</span>
    <span class="n">elements</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="n">element</span><span class="p">.</span><span class="nf">acceptChildren</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">collect</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">)</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">&lt;</span><span class="nc">IrElement</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="n">element</span><span class="p">.</span><span class="nf">accept</span><span class="p">(</span><span class="nc">CollectingVisitor</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="k">null</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <h1 id="depth-versus-breadth">Depth Versus Breadth</h1> <p>The astute reader will have noticed at this point that the visitor pattern I have been explaining is just a form of <a href="https://en.wikipedia.org/wiki/Tree_traversal">tree traversal</a>, and more specifically <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first traversal</a>. While it is possible to perform a <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first traversal</a>, it is a bit more complicated. Like most breadth-first search algorithms a queue of elements must be maintained and the children of the current element must be added into that queue after processing the element.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">breadthFirstCollect</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">)</span> <span class="p">=</span> <span class="n">buildList</span><span class="p">&lt;</span><span class="nc">IrElement</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">queue</span> <span class="p">=</span> <span class="nc">ArrayDeque</span><span class="p">&lt;</span><span class="nc">IrElement</span><span class="p">&gt;()</span>
  <span class="kd">val</span> <span class="py">visitor</span> <span class="p">=</span> <span class="kd">object</span> <span class="err">: </span><span class="nc">IrElementVisitor</span><span class="p">&lt;</span><span class="nc">Unit</span><span class="p">,</span> <span class="nc">Nothing</span><span class="p">?&gt;</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">visitElement</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nc">IrElement</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="nc">Nothing</span><span class="p">?)</span> <span class="p">{</span>
      <span class="n">queue</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">queue</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">queue</span><span class="p">.</span><span class="nf">isNotEmpty</span><span class="p">())</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">current</span> <span class="p">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">removeFirst</span><span class="p">()</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="c1">// add element to collection</span>
    <span class="n">current</span><span class="p">.</span><span class="nf">acceptChildren</span><span class="p">(</span><span class="n">visitor</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="c1">// add children to element queue</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>So while breadth-first traversal is possible, I have not found any use for it when dealing with Koltin IR, nor have I noticed any use of it in the Kotlin compiler code base.</p> <hr /> <p>Hopefully you now have a better understanding of how a Kotlin IR tree can be navigated. Remember, if you want to experiment with IR navigation or build your own compiler plugin, check out my <a href="https://github.com/bnorm/kotlin-ir-plugin-template">GitHub template</a> for IR based Kotlin compiler plugins!</p> <div class="center"> <div class="divider"></div> <span>Join the conversation!</span> <div class='jekyll-twitter-plugin'><blockquote class="twitter-tweet" align="center"><p lang="en" dir="ltr">Part 3 is hot off the press! Why hang with friends when you can visit Kotlin IR instead? üè° <a href="https://t.co/j2cCFWcekE">https://t.co/j2cCFWcekE</a></p>&mdash; Brian Norman üê¢ (@bnormcodes) <a href="https://twitter.com/bnormcodes/status/1335261994769899522?ref_src=twsrc%5Etfw">December 5, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> </div> <!-- reddit? --> </div> </article> <div class="page-navigation code"> <a class="next" href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-4" title="NEXT: Writing Your Second Kotlin Compiler Plugin, Part 4 ‚Äî Building Kotlin IR">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="https://blog.bnorm.dev/" title="Back to Index">Index</a> <span> &middot; </span> <a class="prev" href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2" title="PREV: Writing Your Second Kotlin Compiler Plugin, Part 2 ‚Äî Inspecting Kotlin IR">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&copy; 2020 Brian Norman</span> <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/the-plain">The Plain theme</a>.</small></span> </div> </body> </html>

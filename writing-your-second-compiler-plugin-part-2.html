<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Writing Your Second Kotlin Compiler Plugin, Part 2 ‚Äî Inspecting Kotlin IR ¬∑ Dev Blog by Brian</title> <meta name="description" content=" At the time of writing this article, Kotlin compatibility for IR backend is in Alpha status andthe compiler plugin API is Experimental. As such, informatio..."> <link rel="icon" href="https://blog.bnorm.dev/assets/favicon.png"> <link rel="apple-touch-icon" href="https://blog.bnorm.dev/assets/touch-icon.png"> <link rel="stylesheet" href="https://blog.bnorm.dev/assets/core.css"> <link rel="canonical" href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2"> <link rel="alternate" type="application/atom+xml" title="Dev Blog by Brian" href="https://blog.bnorm.dev/feed.xml" /> <!-- OpenGraph metadatas --> <meta name="og:type" content="article"> <meta name="og:site_name" content="Dev Blog by Brian"> <meta name="og:title" content="Writing Your Second Kotlin Compiler Plugin, Part 2 ‚Äî Inspecting Kotlin IR"> <meta name="og:url" content="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2"> <meta name="og:description" content="Inspecting Kotlin IR"> <!-- Twitter cards metadatas --> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@bnormcodes"> <meta name="twitter:creator" content="@bnormcodes"> <meta name="twitter:title" content="Writing Your Second Kotlin Compiler Plugin, Part 2 ‚Äî Inspecting Kotlin IR"> <meta name="twitter:url" content="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2"> <meta name="twitter:description" content="Inspecting Kotlin IR"> <!-- Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SH69BHV31K"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SH69BHV31K'); </script> </head> <body> <div class="header"> <aside class="logo"> <a href="https://blog.bnorm.dev/"> <img src="https://avatars2.githubusercontent.com/u/1074449?v=4" alt="" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <div class="social-media-list"> <div> <a href="https://github.com/bnorm"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> bnorm</a> </div> <div> <a href="https://www.twitter.com/bnormcodes"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> bnormcodes</a> </div> </div> </div> <div id="content"> <article> <div class="center"> <h1 class="title">Writing Your Second Kotlin Compiler Plugin, Part 2 ‚Äî Inspecting Kotlin IR</h1> <time class="code">November 28, 2020</time> </div> <div class="divider"></div> <blockquote> <p>At the time of writing this article, <a href="https://kotlinlang.org/docs/reference/evolution/components-stability.html">Kotlin compatibility</a> for IR backend is in Alpha status and the compiler plugin API is Experimental. As such, information contained in this article about IR and compiler plugins could be out-of-date or incorrect. If official documentation exists, please refer to it first.</p> </blockquote> <p>In <a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-1">Part 1</a> we learned how to set up a Gradle project for building a Kotlin compiler plugin. In this part we will drive right into the structure of Kotlin IR and what it looks like.</p> <ul> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-1">Part 1 - Project Setup</a></li> <li><a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2">Part 2 - Inspecting Kotlin IR</a></li> <li>Part 3 - Navigating Kotlin IR</li> <li>Part 4 - Transforming Kotlin IR</li> <li>Part 5 - ?</li> <li>Part ? - Publishing a Kotlin Compiler Plugin</li> </ul> <h1 id="foundation">Foundation</h1> <p>Kotlin intermediate representation (IR) is an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree</a> for representing Kotlin code. Kotlin code is represented this way because Kotlin is a high-level programming language, allowing for many advanced programming concepts. Before it can be converted to JVM byte code, JavaScript, or LLVM‚Äôs own IR, these high-level concepts need to be lowered. Many of these ‚Äúlowerings‚Äù are the same across all Kotlin platforms - <code class="language-plaintext highlighter-rouge">suspend</code> functions for example - which makes having a common backend representation for Kotlin extremely useful. (Not to mention useful for compiler plugins!)</p> <p>Every node in the Kotlin IR syntax tree implements <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/IrElement.kt">IrElement</a>. Elements of the syntax tree represent things like modules, packages, files, classes, properties, functions, parameters, <code class="language-plaintext highlighter-rouge">if</code> statements, function invocations, and much, much, more. Let‚Äôs see what this actually looks like!</p> <h1 id="your-new-best-friend-irelementdump">Your New Best Friend: <code class="language-plaintext highlighter-rouge">IrElement.dump()</code></h1> <p>From <a href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-1">Part 1</a> we learned our entry point into IR is through a <code class="language-plaintext highlighter-rouge">IrGenerationExtension</code> instance. This class must implement a function which takes a <code class="language-plaintext highlighter-rouge">IrModuleFragment</code> and <code class="language-plaintext highlighter-rouge">IrPluginContext</code> parameter. Given a compiler plugin with the following implementation:</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">fun</span> <span class="nf">generate</span><span class="p">(</span><span class="n">moduleFragment</span><span class="p">:</span> <span class="nc">IrModuleFragment</span><span class="p">,</span> <span class="n">pluginContext</span><span class="p">:</span> <span class="nc">IrPluginContext</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">println</span><span class="p">(</span><span class="n">moduleFragment</span><span class="p">.</span><span class="nf">dump</span><span class="p">())</span>
<span class="p">}</span>
</code></pre></div></div> <p>And a simple program with the following code:</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nf">println</span><span class="p">(</span><span class="nf">debug</span><span class="p">())</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">debug</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nc">String</span> <span class="p">=</span> <span class="s">"World"</span><span class="p">)</span> <span class="p">=</span> <span class="s">"Hello, $name!"</span>
</code></pre></div></div> <p>The compiler plugin will output the following:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MODULE_FRAGMENT name:&lt;main&gt;
  FILE fqName:&lt;root&gt; fileName:/var/folders/dk/9hdq9xms3tv916dk90l98c01p961px/T/Kotlin-Compilation3223338783072974845/sources/main.kt
    FUN name:main visibility:public modality:FINAL &lt;&gt; () returnType:kotlin.Unit
      BLOCK_BODY
        CALL 'public final fun println (message: kotlin.Any?): kotlin.Unit [inline] declared in kotlin.io.ConsoleKt' type=kotlin.Unit origin=null
          message: CALL 'public final fun debug (name: kotlin.String): kotlin.String declared in &lt;root&gt;' type=kotlin.String origin=null
    FUN name:debug visibility:public modality:FINAL &lt;&gt; (name:kotlin.String) returnType:kotlin.String
      VALUE_PARAMETER name:name index:0 type:kotlin.String
        EXPRESSION_BODY
          CONST String type=kotlin.String value="World"
      BLOCK_BODY
        RETURN type=kotlin.Nothing from='public final fun debug (name: kotlin.String): kotlin.String declared in &lt;root&gt;'
          STRING_CONCATENATION type=kotlin.String
            CONST String type=kotlin.String value="Hello, "
            GET_VAR 'name: kotlin.String declared in &lt;root&gt;.debug' type=kotlin.String origin=null
            CONST String type=kotlin.String value="!"
</code></pre></div></div> <p>The extension function <code class="language-plaintext highlighter-rouge">IrElement.dump()</code> has been my favorite tool when developing IR compiler plugins. It allows for dumping an IR tree from any specific point and saving the output from run to run. This has allowed me to write the code I want generated and take a dump of it for comparing against as I build the IR compiler plugin generation. It has been my best friend.</p> <p>Let‚Äôs break this IR dump down into manageable pieces and compare it against the simple program.</p> <h1 id="the-pieces">The Pieces</h1> <h2 id="fun-main"><code class="language-plaintext highlighter-rouge">fun main()</code></h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FUN name:main visibility:public modality:FINAL &lt;&gt; () returnType:kotlin.Unit
</code></pre></div></div> <p>This is the <code class="language-plaintext highlighter-rouge">main()</code> function definition from our simple program above. It defines the function with the name, visibility, modality, and type signature of the function. We can clearly see that this is a <code class="language-plaintext highlighter-rouge">public</code> and <code class="language-plaintext highlighter-rouge">final</code> function named <code class="language-plaintext highlighter-rouge">main</code> which takes no parameters - value (<code class="language-plaintext highlighter-rouge">()</code>) or type (<code class="language-plaintext highlighter-rouge">&lt;&gt;</code>) - and returns <code class="language-plaintext highlighter-rouge">kotlin.Unit</code>.</p> <h2 id="fun-debugname-string--"><code class="language-plaintext highlighter-rouge">fun debug(name: String = ...)</code></h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FUN name:debug visibility:public modality:FINAL &lt;&gt; (name:kotlin.String) returnType:kotlin.String
</code></pre></div></div> <p>Vary similar to <code class="language-plaintext highlighter-rouge">main()</code>, but the function <code class="language-plaintext highlighter-rouge">debug()</code> takes a single value parameter named <code class="language-plaintext highlighter-rouge">name</code> which is of type <code class="language-plaintext highlighter-rouge">String</code> and also returns a <code class="language-plaintext highlighter-rouge">String</code>. Notice the default value is not included in the function definition dump but rather part of the parameter dump. Functions with and without default parameters have the same signature, they are just called differently as we will see later.</p> <h2 id="name-string--world"><code class="language-plaintext highlighter-rouge">name: String = "World"</code></h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>VALUE_PARAMETER name:name index:0 type:kotlin.String
  EXPRESSION_BODY
    CONST String type=kotlin.String value="World"
</code></pre></div></div> <p>The value parameter <code class="language-plaintext highlighter-rouge">name</code> for the function <code class="language-plaintext highlighter-rouge">debug()</code> is defined as having an <code class="language-plaintext highlighter-rouge">EXPRESSION_BODY</code> which is just the constant string <code class="language-plaintext highlighter-rouge">World</code>. In Kotlin IR, there are mainly 2 different types of ‚Äúbodies‚Äù: <code class="language-plaintext highlighter-rouge">BLOCK_BODY</code> and <code class="language-plaintext highlighter-rouge">EXPRESSION_BODY</code>. An expression body holds a single expression while a block body can hold multiple statements. <a href="https://blog.kotlin-academy.com/kotlin-programmer-dictionary-statement-vs-expression-e6743ba1aaa0">Kotlin Academy has a great article</a> on the difference between statements and expressions but to simplify: a statement is a line of code and an expression is a statement which returns a value. The constant string <code class="language-plaintext highlighter-rouge">World</code> is our first example of an expression.</p> <h2 id="hello-name"><code class="language-plaintext highlighter-rouge">"Hello, $name!"</code></h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FUN name:debug visibility:public modality:FINAL &lt;&gt; (name:kotlin.String) returnType:kotlin.String
  ...
  BLOCK_BODY
    RETURN type=kotlin.Nothing from='public final fun debug (name: kotlin.String): kotlin.String declared in &lt;root&gt;'
      STRING_CONCATENATION type=kotlin.String
        CONST String type=kotlin.String value="Hello, "
        GET_VAR 'name: kotlin.String declared in &lt;root&gt;.debug' type=kotlin.String origin=null
        CONST String type=kotlin.String value="!"
</code></pre></div></div> <p>The body of the <code class="language-plaintext highlighter-rouge">debug()</code> function is a <code class="language-plaintext highlighter-rouge">BLOCK_BODY</code> with a single statement, a <code class="language-plaintext highlighter-rouge">return</code>. According to the IR dump, this return has a type of <code class="language-plaintext highlighter-rouge">Nothing</code> which makes sense if you remember that <a href="https://kotlinlang.org/docs/reference/returns.html"><code class="language-plaintext highlighter-rouge">return</code> in Kotlin is actually an <em>expression</em></a>. The value being returned is also an expression, in this case a string, which is the concatenation of 3 expressions: <code class="language-plaintext highlighter-rouge">"Hello, "</code>, getting the value of the <code class="language-plaintext highlighter-rouge">name</code> parameter, and <code class="language-plaintext highlighter-rouge">"!"</code>.</p> <h2 id="printlndebug"><code class="language-plaintext highlighter-rouge">println(debug())</code></h2> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CALL 'public final fun println (message: kotlin.Any?): kotlin.Unit [inline] declared in kotlin.io.ConsoleKt' type=kotlin.Unit origin=null
  message: CALL 'public final fun debug (name: kotlin.String): kotlin.String declared in &lt;root&gt;' type=kotlin.String origin=null
</code></pre></div></div> <p>Function calls include which function is being called along with any parameters being provided. In this example, the <code class="language-plaintext highlighter-rouge">println()</code> call includes a single parameter named <code class="language-plaintext highlighter-rouge">message</code>. This parameter value is an expression which is another function call to <code class="language-plaintext highlighter-rouge">debug()</code>. Notice that no parameter values are defined for the <code class="language-plaintext highlighter-rouge">debug()</code> function even though it has a single parameter <code class="language-plaintext highlighter-rouge">name</code>. This is because <code class="language-plaintext highlighter-rouge">name</code> has a default value and therefore specifying a value is not required.</p> <p>Also note that the <code class="language-plaintext highlighter-rouge">println()</code> function is an <code class="language-plaintext highlighter-rouge">inline</code> function. <a href="https://github.com/JetBrains/kotlin/blob/1.4.20/compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower/inline/FunctionInlining.kt">Inlining is a ‚Äúlowering‚Äù</a> which is performed later in the compilation. This allows IR plugins to generate calls to inline functions without having to perform the inlining.</p> <h1 id="dump-the-world">Dump The World</h1> <p>Try dumping some simple programs of your own! The <a href="https://github.com/bnorm/kotlin-ir-plugin-template">GitHub template</a> for Kotlin IR compiler plugins is ready for you to edit the unit tests and compiler plugin! What code changes cause the IR dump to change? What codes changes <em>don‚Äôt</em> cause the IR dump to change? What does the dump of an <code class="language-plaintext highlighter-rouge">if</code> statement in Kotlin IR look like? (hint: how are <code class="language-plaintext highlighter-rouge">when</code> and <code class="language-plaintext highlighter-rouge">if</code> similar?)</p> <div class="center"> <div class="divider"></div> <span>Join the conversation!</span> <div class='jekyll-twitter-plugin'><blockquote class="twitter-tweet" align="center"><p lang="en" dir="ltr">Part 2! Let&#39;s take a look at some Kotlin IR! ü§ì <a href="https://t.co/E088of4DeJ">https://t.co/E088of4DeJ</a></p>&mdash; Brian Norman üê¢ (@bnormcodes) <a href="https://twitter.com/bnormcodes/status/1332744643633623041?ref_src=twsrc%5Etfw">November 28, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> </div> <!-- reddit? --> </div> </article> <div class="page-navigation code"> <a class="home" href="https://blog.bnorm.dev/" title="Back to Index">Index</a> <span> &middot; </span> <a class="prev" href="https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-1" title="PREV: Writing Your Second Kotlin Compiler Plugin, Part 1 ‚Äî Project Setup">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&copy; 2020 Brian Norman</span> <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/the-plain">The Plain theme</a>.</small></span> </div> </body> </html>

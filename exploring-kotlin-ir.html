<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Exploring Kotlin IR ¬∑ Dev Blog by Brian</title> <meta name="description" content=" At the time of writing this article, Kotlin IR is experimental. As such, information contained inthis article about IR could be out-of-date or incorrect. I..."> <link rel="icon" href="https://blog.bnorm.dev/assets/favicon.png"> <link rel="apple-touch-icon" href="https://blog.bnorm.dev/assets/touch-icon.png"> <link rel="stylesheet" href="https://blog.bnorm.dev/assets/core.css"> <link rel="canonical" href="https://blog.bnorm.dev/exploring-kotlin-ir"> <link rel="alternate" type="application/atom+xml" title="Dev Blog by Brian" href="https://blog.bnorm.dev/feed.xml" /> <!-- Twitter cards metadatas --> <meta name="twitter:card" content="summary"> <meta name="twitter:site" content="@bnormcodes"> <meta name="twitter:creator" content="@bnormcodes"> <meta name="twitter:title" content="Exploring Kotlin IR"> <meta name="twitter:url" content="https://blog.bnorm.dev/exploring-kotlin-ir"> <meta name="twitter:description" content="Dev blog by Brian"> <!-- Google Analytics --> <script async src="https://www.googletagmanager.com/gtag/js?id=G-SH69BHV31K"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-SH69BHV31K'); </script> </head> <body> <div class="header"> <aside class="logo"> <a href="https://blog.bnorm.dev/"> <img src="https://avatars2.githubusercontent.com/u/1074449?v=4" alt="" class="logo-avatar"> </a> <span class="logo-prompt code">Back to Index</span> </aside> <div class="social-media-list"> <div> <a href="https://github.com/bnorm"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> bnorm</a> </div> <div> <a href="https://www.twitter.com/bnormcodes"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> bnormcodes</a> </div> </div> </div> <div id="content"> <article> <div class="center"> <h1 class="title">Exploring Kotlin IR</h1> <time class="code">February 10, 2020</time> </div> <div class="divider"></div> <blockquote> <p>At the time of writing this article, Kotlin IR is experimental. As such, information contained in this article about IR could be out-of-date or incorrect. If official documentation for Kotlin IR exists, please refer to it first.</p> </blockquote> <p>Ever since learning about them, I‚Äôve been very interested in Kotlin compiler plugins. Even the <a href="https://github.com/JetBrains/kotlin/tree/master/plugins">limited list of official supported plugins</a> hint at the potential available. A plugin like <code class="language-plaintext highlighter-rouge">kotlin-serialization</code> shows how it is possible to generate code for <a href="https://en.wikipedia.org/wiki/Marshalling_(computer_science)">marshalling</a> a Kotlin class. A plugin like <code class="language-plaintext highlighter-rouge">allopen</code> shows it‚Äôs possible to transform classes to be non-final at runtime. It is Java annotation processing; but with more power.</p> <p>My adventure into this world started a few months ago when I once again looked longingly at a Groovy language feature called <a href="https://groovy-lang.org/testing.html#_power_assertions">Power Assertions</a>. If you are unfamiliar with this language feature, <a href="https://dontmindthelanguage.wordpress.com/2009/12/11/groovy-1-7-power-assert/">it was original developed by the Spock testing framework, and introduced in Groovy 1.7</a>. Its goal is to show the value of everything involved in the assertion which failed.</p> <div class="language-groovy highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">9</span>
 
<span class="k">assert</span> <span class="mi">91</span> <span class="o">==</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

<span class="c1">// Output:             </span>
<span class="c1">//</span>
<span class="c1">// Exception thrown</span>
<span class="c1">//</span>
<span class="c1">// Assertion failed: </span>
<span class="c1">//</span>
<span class="c1">// assert 91 == a * b</span>
<span class="c1">//           |  | | |</span>
<span class="c1">//           |  10| 9</span>
<span class="c1">//           |    90</span>
<span class="c1">//           false</span>
<span class="c1">//</span>
<span class="c1">//     at ConsoleScript2.run(ConsoleScript2:4)</span>
</code></pre></div></div> <p>This context as to why the assertion failed is indeed something to desire. Many libraries in the JVM ecosystem (AssertJ, Hamcrest, Truth, Kluent, Atrium, Strikt, etc) provide meaningful error messages but they are usually limited to the known types of the library. Many of these libraries have ways to provide custom assertion extensions so you can provide something meaningful when testing your own classes. But I‚Äôve always seen this as boiler plate and found it tedious to write.</p> <h1 id="introducing-kotlin-power-assert">Introducing: kotlin-power-assert</h1> <p><a href="https://github.com/bnorm/kotlin-power-assert">kotlin-power-assert</a> is a Kotlin compiler plugin which finds every call to <code class="language-plaintext highlighter-rouge">kotlin.assert(...)</code> and transforms it to include all the expressions in the assertion in the error message.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">val</span> <span class="py">hello</span> <span class="p">=</span> <span class="s">"Hello"</span>
<span class="nf">assert</span><span class="p">(</span><span class="n">hello</span><span class="p">.</span><span class="n">length</span> <span class="p">==</span> <span class="s">"World"</span><span class="p">.</span><span class="nf">substring</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">).</span><span class="n">length</span><span class="p">)</span> <span class="p">{</span> <span class="s">"Incorrect length"</span> <span class="p">}</span>

<span class="c1">// Output:</span>
<span class="c1">//</span>
<span class="c1">// java.lang.AssertionError: Incorrect length</span>
<span class="c1">// assert(hello.length == "World".substring(1, 4).length)</span>
<span class="c1">//        |     |      |          |               |</span>
<span class="c1">//        |     |      |          |               3</span>
<span class="c1">//        |     |      |          orl</span>
<span class="c1">//        |     |      false</span>
<span class="c1">//        |     5</span>
<span class="c1">//        Hello</span>
<span class="c1">//         at &lt;stacktrace&gt;</span>
</code></pre></div></div> <p>This is done via an <code class="language-plaintext highlighter-rouge">IrGenerationExtension</code> which is a specific kind of extension to the Kotlin compiler. From this extension point, you are given access to the IR layout of the file being compiled and are allowed to transform it before the Kotlin compiler continues to the next phase of compilation.</p> <p>If you want to learn more about the architecture of Kotlin compiler plugins I highly recommend watching <a href="https://www.youtube.com/watch?v=w-GMlaziIyo">Kevin Most‚Äôs presentation from KotlinConf 2018</a> which goes into details not covered here.</p> <h1 id="kotlin-ir">Kotlin IR</h1> <p>Kotlin IR, or Kotlin Intermediate Representation, is the new internal representation used by the Kotlin compiler when it parses Kotlin source files. It uses this representation to than perform a series of <a href="https://github.com/JetBrains/kotlin/tree/master/compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower">‚Äúlowerings‚Äù</a> which transform the code.</p> <p>These lowering operations include <a href="https://github.com/JetBrains/kotlin/blob/master/compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower/TailrecLowering.kt">tailrec transformation</a>, <a href="https://github.com/JetBrains/kotlin/blob/master/compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower/StringConcatenationLowering.kt">string concatenation to StringBuilder</a>, <a href="https://github.com/JetBrains/kotlin/blob/master/compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower/AbstractSuspendFunctionsLowering.kt">suspend function transformation</a>, and <a href="https://github.com/JetBrains/kotlin/blob/master/compiler/ir/backend.common/src/org/jetbrains/kotlin/backend/common/lower/loops/ForLoopsLowering.kt">for-loop optimizations</a>. These lowerings are then performed in phases, with more general transformations performed first. Once all lowerings are complete, each compiler backend, one for each supported platform (JVM, JS, or Native), takes the IR and translates it into the platform specific representation.</p> <p>By using an intermediate representation, the Kotlin compiler is able to share lowerings across all the compiler backends. It also allows developers to write a single compiler plugin which will work on all platforms. Otherwise a plugin which wants to support all Kotlin platforms would need to write a transformation for each platform specific representation.</p> <h1 id="transfroming-kotlin-ir">Transfroming Kotlin IR</h1> <p>Kotlin IR is represented as a tree of elements. To navigate, you can use an <code class="language-plaintext highlighter-rouge">IrElementVisitor</code> which will visit each <code class="language-plaintext highlighter-rouge">IrElement</code>. If you want to transform the code, you can use an <code class="language-plaintext highlighter-rouge">IrElementTransformer</code> which will allow you to manipulate the elements visited and even return a completely different element in place of the one being visited. To create an IR tree of your own, you can use the <a href="https://github.com/JetBrains/kotlin/tree/master/compiler/ir/ir.tree/src/org/jetbrains/kotlin/ir/builders">many builder functions</a> available.</p> <p>As Kotlin IR is still experimental, only a few of the official compiler plugins have been converted to also support IR. However, many lowerings are currently available which provide good examples to explore.</p> <h1 id="transforming-assert-calls">Transforming assert() Calls</h1> <p>So with a little background on Kotlin IR, how is the assertion function transformed to include additional information?</p> <p>It all starts with an <code class="language-plaintext highlighter-rouge">IrElementTransformer</code> which navigates the IR tree and visits each instance of an <code class="language-plaintext highlighter-rouge">IrCall</code>. This represents every call to any function. If the function being called is <code class="language-plaintext highlighter-rouge">assert()</code>, then the call needs to be transformed.</p> <p>Next, the IR tree is navigated from that point, finding every instance of an <code class="language-plaintext highlighter-rouge">IrExpression</code>. An expression is anything that can return a value: function calls, variable/field access, constants, if/when expressions, etc.</p> <p>Then every <code class="language-plaintext highlighter-rouge">IrExpression</code> found is moved to a temporary variable (via <code class="language-plaintext highlighter-rouge">irTemporary</code> builder) and replaced with an access expression to the temporary variable (via <code class="language-plaintext highlighter-rouge">irGet</code> builder). This allows the error message to access the same temporary variables used by the assertion condition.</p> <p>Once the assertion expressions are transformed, the assertion call is replaced with a series of <code class="language-plaintext highlighter-rouge">if</code> statements (using <code class="language-plaintext highlighter-rouge">irIfThen</code> builder) and throw statements (using <code class="language-plaintext highlighter-rouge">irThrow</code> builder). The constructor call to <code class="language-plaintext highlighter-rouge">AssertionError</code> can then include all the temporary variables, formatted appropriately and include the source code of the original <code class="language-plaintext highlighter-rouge">assert()</code> call.</p> <p>Finally, to get the source code for the original <code class="language-plaintext highlighter-rouge">assert()</code> call, start with getting the source code for the entire file. This can be accessed through visiting the <code class="language-plaintext highlighter-rouge">IrFile</code> and using the path extension function to get the <code class="language-plaintext highlighter-rouge">path</code> to the source file being compiled. From there, source code range information can be retrieved from each <code class="language-plaintext highlighter-rouge">IrElement</code> using the <code class="language-plaintext highlighter-rouge">fileEntry</code> from the parent <code class="language-plaintext highlighter-rouge">IrFile</code>.</p> <div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">override</span> <span class="k">fun</span> <span class="nf">visitFile</span><span class="p">(</span><span class="n">declaration</span><span class="p">:</span> <span class="nc">IrFile</span><span class="p">):</span> <span class="nc">IrFile</span> <span class="p">{</span>
  <span class="n">file</span> <span class="p">=</span> <span class="n">declaration</span>
  <span class="n">fileSource</span> <span class="p">=</span> <span class="nc">File</span><span class="p">(</span><span class="n">declaration</span><span class="p">.</span><span class="n">path</span><span class="p">).</span><span class="nf">readText</span><span class="p">()</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>

<span class="k">override</span> <span class="k">fun</span> <span class="nf">visitCall</span><span class="p">(</span><span class="n">expression</span><span class="p">:</span> <span class="nc">IrCall</span><span class="p">):</span> <span class="nc">IrExpression</span> <span class="p">{</span>
  <span class="kd">val</span> <span class="py">callSource</span> <span class="p">=</span> <span class="n">fileSource</span><span class="p">.</span><span class="nf">substring</span><span class="p">(</span><span class="n">expression</span><span class="p">.</span><span class="n">startOffset</span><span class="p">,</span> <span class="n">expression</span><span class="p">.</span><span class="n">endOffset</span><span class="p">)</span>
  <span class="kd">val</span> <span class="py">callIndent</span> <span class="p">=</span> <span class="n">file</span><span class="p">.</span><span class="n">fileEntry</span><span class="p">.</span><span class="nf">getSourceRangeInfo</span><span class="p">(</span><span class="n">expression</span><span class="p">.</span><span class="n">startOffset</span><span class="p">,</span> <span class="n">expression</span><span class="p">.</span><span class="n">endOffset</span><span class="p">).</span><span class="n">startColumnNumber</span>
  <span class="o">..</span><span class="p">.</span>
<span class="p">}</span>
</code></pre></div></div> <p>Putting all this information together, the expression temporary variables are sorted based on start column and included in the assertion message string with some ‚Äúfancy‚Äù formatting (using <code class="language-plaintext highlighter-rouge">irConcat</code> and <code class="language-plaintext highlighter-rouge">irString</code> builders).</p> <p>Unfortunately, in reality it is more complicated that what was just described. Boolean expression which include <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> or <code class="language-plaintext highlighter-rouge">||</code> tend to make things more complicated due to <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short-circuiting</a>. But hopefully this simplification helps you understand what is going on behind the scenes.</p> <h1 id="writing-your-own-plugin">Writing Your Own Plugin</h1> <p>If you have an idea for a Kotlin compiler plugin, the first thing I recommend is to use the fantastic library <a href="https://github.com/tschuchortdev/kotlin-compile-testing">kotlin-compile-testing</a>. This library will allow you to compile code in unit tests and to even load the compiled code so you can test it‚Äôs behavior.</p> <p>The second thing I recommend is to set your expectations correctly. As Kotlin IR is still experimental, there are still a number of things which do not work well. It could be a while before Kotlin IR is the default mode for the Kotlin compiler. Make sure you are comfortable with these risks before using or writing a compiler plugin based on IR.</p> <p>And finally, clone and load up the Kotlin git repository. Being able to navigate through all the IR code and lowerings was incredibly useful to find examples on how to perform different transformations.</p> <div class="center"> <div class="divider"></div> <span>Join the conversation!</span> <div class='jekyll-twitter-plugin'><blockquote class="twitter-tweet" align="center"><p lang="en" dir="ltr">Just released kotlin-power-assert version 0.1.0 and did a brain dump about creating this compiler plugin. üß† Check it out! <a href="https://t.co/l9zTCHxw7e">https://t.co/l9zTCHxw7e</a></p>&mdash; Brian Norman üê¢ (@bnormcodes) <a href="https://twitter.com/bnormcodes/status/1226929535620390912?ref_src=twsrc%5Etfw">February 10, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> </div> <!-- reddit? --> </div> </article> <div class="page-navigation code"> <a class="next" href="https://blog.bnorm.dev/kotlin-optin-annotation-as-a-scoping-tool" title="NEXT: Kotlin OptIn Annotation as a Scoping Tool">&lt;&lt;</a> <span> &middot; </span> <a class="home" href="https://blog.bnorm.dev/" title="Back to Index">Index</a> <span> &middot; </span> <a class="prev" href="https://blog.bnorm.dev/unused-type-parameters-on-kotlin-inline-classes" title="PREV: "Unused" Type Parameters on Kotlin Inline Classes">&gt;&gt;</a> </div> </div> <div class="footer"> <span class="block">&copy; 2020 Brian Norman</span> <span class="block"><small>&lt;/&gt; Powered by <a href="https://jekyllrb.com/">Jekyll</a> and <a href="https://github.com/heiswayi/the-plain">The Plain theme</a>.</small></span> </div> </body> </html>
